import { WebClient, KnownBlock } from '@slack/web-api';
import { BriefContent } from '../types';

const useCanvasApi = process.env.USE_CANVAS_API === 'true';
const canvasUserToken = process.env.SLACK_USER_TOKEN;
const canvasUserClient = canvasUserToken ? new WebClient(canvasUserToken) : null;

export async function deliverBrief(args: {
  client: WebClient;
  userId: string;
  brief: BriefContent;
}): Promise<void> {
  const { client, userId, brief } = args;
  const markdown = brief.markdown || buildMarkdownFromSections(brief);

  const canvasApiClient = canvasUserClient || client;

  if (useCanvasApi && canvasApiClient) {
    try {
      await canvasApiClient.apiCall('canvases.create', {
        title: brief.title,
        content_markdown: markdown,
        share: { user_ids: [userId] },
      });
      return;
    } catch (error) {
      console.warn('[canvas] Falling back to Block Kit:', error);
    }
  }

  const fileName = `${slugify(brief.title)}.md`;
  await client.files.uploadV2({
    channel_id: userId,
    filename: fileName,
    title: brief.title,
    content: markdown,
  });

  await client.chat.postMessage({
    channel: userId,
    text: `${brief.title} is ready.`,
    blocks: buildBlocksFromBrief(brief),
  });
}

export async function shareExistingCanvas({
  client,
  userId,
  canvasId,
  canvasTitle,
}: {
  client: WebClient;
  userId: string;
  canvasId: string;
  canvasTitle?: string;
}): Promise<boolean> {
  if (!canvasUserClient) {
    console.warn('[canvas] Missing Canvas user token; cannot share existing Canvas.');
    await client.chat.postMessage({
      channel: userId,
      text: 'Canvas sharing is unavailable because SLACK_USER_TOKEN is not configured.',
    });
    return false;
  }

  try {
    await canvasUserClient.apiCall('canvases.share', {
      canvas_id: canvasId,
      share: { user_ids: [userId] },
    });
    return true;
  } catch (error) {
    console.warn('[canvas] Failed to share existing Canvas, falling back to info DM.', error);
    await client.chat.postMessage({
      channel: userId,
      text: canvasTitle
        ? `I couldn't share *${canvasTitle}*. Please make sure I have Canvas permissions and try again.`
        : 'I could not share that Canvas. Please verify it still exists.',
    });
    return false;
  }
}

function buildBlocksFromBrief(brief: BriefContent): KnownBlock[] {
  const blocks: KnownBlock[] = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: brief.title.slice(0, 150),
      },
    },
  ];

  if (brief.subtitle) {
    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: brief.subtitle,
        },
      ],
    });
  }

  brief.sections.forEach((section) => {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${section.title}*\n${section.body?.join('\n') || ''}`,
      },
    });

    if (section.fields?.length) {
      blocks.push({
        type: 'section',
        fields: section.fields.map((field) => ({
          type: 'mrkdwn',
          text: `*${field.label}*\n${field.value}`,
        })),
      });
    }
  });

  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: 'Generated by Global Sales Insights',
      },
    ],
  });

  return blocks;
}

function buildMarkdownFromSections(brief: BriefContent): string {
  const lines = [`# ${brief.title}`, ''];
  if (brief.subtitle) {
    lines.push(`_${brief.subtitle}_`, '');
  }
  brief.sections.forEach((section) => {
    lines.push(`## ${section.title}`);
    section.body?.forEach((line) => lines.push(line));
    section.fields?.forEach((field) => lines.push(`- **${field.label}:** ${field.value}`));
    lines.push('');
  });
  return lines.join('\n');
}

function slugify(value: string): string {
  return value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || 'brief';
}
